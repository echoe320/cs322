LLLLLLLLLLLLLLLLLLLLLLLL

TODO:
1) figure out how to access Memory's reg r and Number's int64_t num fields
  - right now they're set as constants
2) test computation of GEN and KILL sets
3) compute IN and OUT sets from GEN, KILL, successor/predecessor

#################### CHANGELOG ASYNCRONOUS ##################### (new entries go to top of stack)

01/29/2021 (Jacob):
- change VisitInstruction() methods to use get() instead of directly accessing fields
- remove 'using namespace std;' from liveness.cpp
  -> to avoid confusion between std::get<idx>(myTuple) and myClass.get()
- add toString method to parent Item class to allow dynamic_cast
  -> if there is no virtual function to override, you can't use dynamic_cast because the class isn't polymorphic 
  -> add toString override methods to Item's children
    -> none of the toString methods actually work lmao they just return empty string (i just needed it so the classes are recognized as polymorphic)
- updated our TODO list

Update Eugene Jan 29, 2021:
- added reg_list for callee, caller, arg 
  -> used reg::rdi to get the int value for reg enum values
- fixed loops creating callee, caller, arg 
  -> used static_cast<reg>(count) instead of reg(count)
  -> arg_reg_list for arg registers
- started creating get() for each instruction class
  -> changed L2.h to include get functions in the each instruction class
  -> finished implementing get() functions for Instruction_assignment, Instruction_arithmetic, Instruction_crement, Instruction_shift, Instruction_cmp, Instruction_lea, Instruction_calls, Instruction_runtime, Instruction_label, Instruction_goto, Instruction_stackarg -> all Instruction classes have get()
  -> used i.e. std::tuple<Item*, Item*, Item*> get() -> access the fields using indexing?